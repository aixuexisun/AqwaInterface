!**********************************************************************************************************************************
! The AqwaInterface.f90 and  AqwaInterface_Types.f90 make up the AqwaInterface module of the
! FAST Modularization Framework. AqwaInterface_Types is auto-generated based on FAST_Registry.txt.
!..................................................................................................................................
! LICENSING
! Copyright (C) 2015-2016  National Renewable Energy Laboratory
!
!    This file is part of AqwaInterface.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
!> This module contains definitions of compile-time PARAMETERS for the Aqwa Interface module.
!! Every variable defined here MUST have the PARAMETER attribute.
MODULE AqwaInterface_Parameters

   USE NWTC_Library

   IMPLICIT                      NONE

   TYPE(ProgDesc), PARAMETER  :: Aqwa_Ver = ProgDesc( 'AqwaInterface', 'v1.00.00', '21-Feb-2017' )
   CHARACTER(*),   PARAMETER  :: Aqwa_Nickname = 'Aqwa'


! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 01-Sep-2015 14:29:18.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =  0


     ! Platform forces:

   INTEGER(IntKi), PARAMETER      :: AqwaFxi   =  1
   INTEGER(IntKi), PARAMETER      :: AqwaFyi   =  2
   INTEGER(IntKi), PARAMETER      :: AqwaFzi   =  3
   INTEGER(IntKi), PARAMETER      :: AqwaMxi   =  4
   INTEGER(IntKi), PARAMETER      :: AqwaMyi   =  5
   INTEGER(IntKi), PARAMETER      :: AqwaMzi   =  6
   INTEGER(IntKi), PARAMETER      :: AqwaHMFxi =  7
   INTEGER(IntKi), PARAMETER      :: AqwaHMFyi =  8
   INTEGER(IntKi), PARAMETER      :: AqwaHMFzi =  9
   INTEGER(IntKi), PARAMETER      :: AqwaHMMxi = 10
   INTEGER(IntKi), PARAMETER      :: AqwaHMMyi = 11
   INTEGER(IntKi), PARAMETER      :: AqwaHMMzi = 12
   INTEGER(IntKi), PARAMETER      :: AqwaAMFxi = 13
   INTEGER(IntKi), PARAMETER      :: AqwaAMFyi = 14
   INTEGER(IntKi), PARAMETER      :: AqwaAMFzi = 15
   INTEGER(IntKi), PARAMETER      :: AqwaAMMxi = 16
   INTEGER(IntKi), PARAMETER      :: AqwaAMMyi = 17
   INTEGER(IntKi), PARAMETER      :: AqwaAMMzi = 18


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts = 18

!End of code generated by Matlab script
! ===================================================================================================

END MODULE AqwaInterface_Parameters
!**********************************************************************************************************************************
!> This module is an interface between FAST and Aqwa, a commercial software package developed by ANSYS. This interface reads from sockets
!! once per time step, and is valid for loose coupling. Tight coupling is not supported.
MODULE AqwaInterface

   USE NWTC_Library
   USE NWTC_LAPACK
   
   USE AqwaInterface_Parameters
   USE AqwaInterface_Types

   USE, INTRINSIC             :: ISO_C_Binding


   IMPLICIT NONE

   PRIVATE

   !ABSTRACT INTERFACE      ! These are interfaces to the DLL
   INTERFACE      ! These are interfaces for the DLL to be seen externally by ANSYS AQWA

#ifdef __GFORTRAN__
       SUBROUTINE AqwaUserPtfmLdInitialise(DT,TMax)   BIND(C)
#else
       SUBROUTINE AqwaUserPtfmLdInitialise(DT,TMax)    !!!BIND(C)
#endif
         USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_FLOAT
         !DEC$ ATTRIBUTES DEFAULT, STDCALL, DECORATE, ALIAS:'AqwaUserPtfmLdInitialise'::AqwaUserPtfmLdInitialise
         !GCC$ ATTRIBUTES STDCALL :: AqwaUserPtfmLdInitialise
         REAL(C_FLOAT),             INTENT(IN   )  :: DT
         REAL(C_FLOAT),             INTENT(IN   )  :: TMax
      END SUBROUTINE AqwaUserPtfmLdInitialise


#ifdef __GFORTRAN__
      SUBROUTINE AqwaUserPtfmLd( X, XD, ZTime, DirRoot, A2Fast_PtfmAM, A2Fast_PtfmFt) BIND(C)
#else
      SUBROUTINE AqwaUserPtfmLd( X, XD, ZTime, DirRoot, A2Fast_PtfmAM, A2Fast_PtfmFt) !!!BIND(C)
#endif
         USE, INTRINSIC :: ISO_C_Binding, ONLY: C_FLOAT, C_CHAR
         !DEC$ ATTRIBUTES STDCALL, ALIAS:'FastSocketPtfmLd'::AqwaUserPtfmLd
         !DEC$ ATTRIBUTES REFERENCE :: ICALL
         !DEC$ ATTRIBUTES REFERENCE :: ZTIME
         !DEC$ ATTRIBUTES REFERENCE :: ITIME
         !DEC$ ATTRIBUTES REFERENCE :: DTIME
         !DEC$ ATTRIBUTES REFERENCE :: ISTAGE
         !DEC$ ATTRIBUTES REFERENCE :: NSTRUCT
         !DEC$ ATTRIBUTES REFERENCE :: COGXYZ
         !DEC$ ATTRIBUTES REFERENCE :: TMASS
         !DEC$ ATTRIBUTES REFERENCE :: TFORC
         !DEC$ ATTRIBUTES REFERENCE :: XDELU
         !DEC$ ATTRIBUTES REFERENCE :: XVEL
         !DEC$ ATTRIBUTES REFERENCE :: XACC
         !DEC$ ATTRIBUTES REFERENCE :: IERR
         
         !GCC$ ATTRIBUTES STDCALL :: AqwaUserPtfmLd
         CHARACTER(KIND=C_CHAR),    INTENT(IN   )  :: DirRoot
         REAL(C_FLOAT) ,             INTENT(IN   )  :: X(6)           !< Translational and rotational displacement (m, radians) relative to inertial frame.
         REAL(C_FLOAT) ,             INTENT(IN   )  :: XD(6)          !< Translational and rotational velocity (m/s, radians/s) relative to inertial frame.
         REAL(C_FLOAT) ,             INTENT(IN   )  :: ZTime          !< Current time in seconds
         REAL(C_FLOAT) ,             INTENT(  OUT)  :: A2Fast_PtfmAM(6,6)    !< Added mass matrix (kg, kg-m, kg-m^2)
         REAL(C_FLOAT) ,             INTENT(  OUT)  :: A2Fast_PtfmFt(6)      !< Platform forces -- [3 translation (N), 3 moments (N-m)] at reference point.
      END SUBROUTINE AqwaUserPtfmLd

#ifdef __GFORTRAN__
      SUBROUTINE AqwaUserPtfmLdFinalise()  BIND(C)
#else
      SUBROUTINE AqwaUserPtfmLdFinalise()  !!!BIND(C)
#endif
         USE, INTRINSIC :: ISO_C_BINDING
         !DEC$ ATTRIBUTES DEFAULT, STDCALL, DECORATE, ALIAS: 'AqwaUserPtfmLdFinalise'::AqwaUserPtfmLdFinalise
         !GCC$ ATTRIBUTES STDCALL :: AqwaUserPtfmLdFinalise
         ! There is no data to pass.
      END SUBROUTINE AqwaUserPtfmLdFinalise

   END INTERFACE


      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: Aqwa_Init                             ! Initialization routine
   PUBLIC :: Aqwa_End                              ! Ending routine (includes clean up)

   PUBLIC :: Aqwa_UpdateStates                     ! Loose coupling routine for solving for constraint states, integrating
                                                   !   continuous states, and updating discrete states
   PUBLIC :: Aqwa_CalcOutput                       ! Routine for computing outputs

CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
SUBROUTINE Aqwa_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )

   USE, INTRINSIC             :: ISO_C_Binding

   TYPE(Aqwa_InitInputType),        INTENT(IN   )  :: InitInp           !< Input data for initialization routine
   TYPE(Aqwa_InputType),            INTENT(  OUT)  :: u                 !< An initial guess for the input; input mesh must be defined
   TYPE(Aqwa_ParameterType),        INTENT(  OUT)  :: p                 !< Parameters
   TYPE(Aqwa_ContinuousStateType),  INTENT(  OUT)  :: x                 !< Initial continuous states
   TYPE(Aqwa_DiscreteStateType),    INTENT(  OUT)  :: xd                !< Initial discrete states
   TYPE(Aqwa_ConstraintStateType),  INTENT(  OUT)  :: z                 !< Initial guess of the constraint states
   TYPE(Aqwa_OtherStateType),       INTENT(  OUT)  :: OtherState        !< Initial other states
   TYPE(Aqwa_OutputType),           INTENT(  OUT)  :: y                 !< Initial system outputs (outputs are not calculated;
                                                                        !!   only the output mesh is initialized)
   TYPE(Aqwa_MiscVarType),          INTENT(INOUT)  :: m                 !<  Misc variables for optimization (not copied in glue code)
   REAL(DbKi),                      INTENT(INOUT)  :: Interval          !< Coupling interval in seconds: the rate that
                                                                        !!   (1) Aqwa_UpdateStates() is called in loose coupling &
                                                                        !!   (2) Aqwa_UpdateDiscState() is called in tight coupling.
                                                                        !!   Input is the suggested time from the glue code;
                                                                        !!   Output is the actual coupling interval that will be used
                                                                        !!   by the glue code.
   TYPE(Aqwa_InitOutputType),       INTENT(  OUT)  :: InitOut           !< Output for initialization routine
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat           !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg            !< Error message if ErrStat /= ErrID_None


      ! Local variables
   TYPE(Aqwa_InputFile)                            :: InputFileData     ! Data stored in the module's input file
   INTEGER(IntKi)                                  :: ErrStatTmp          ! temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsgTmp           ! temporary Error message if ErrStat /= ErrID_None
   CHARACTER(*),   PARAMETER                       :: RoutineName='Aqwa_Init'
   CHARACTER(ChanLen)                              :: TmpOutList(MaxOutPts)


   REAL(C_FLOAT)                                   :: DLL_DT
   REAL(C_FLOAT)                                   :: DLL_TMax


   !!PROCEDURE(AqwaUserPtfmLdInitialise),POINTER :: AqwaDLL_Init  !To Remove when sure RRD


      ! Initialize variables for this routine
   ErrStat                 = ErrID_None
   ErrMsg                  = ""

   ! dummy variables for the FAST framework:
   ! (initialized to prevent compiler warnings about INTENT(OUT) variables)
   OtherState%DummyOtherState = 0
   z%DummyConstrState = 0.0_ReKi
   xd%Dummy = 0.0_ReKi
   x%Dummy = 0.0_ReKi
   

!!      ! Set some things for the DLL
!!   InputFileData%DLL_InitProcName   = 'AqwaUserPtfmLdInitialise'
!!   InputFileData%DLL_CalcProcName   = 'AqwaUserPtfmLd'
!!   InputFileData%DLL_EndProcName    = 'AqwaUserPtfmLdFinalise'


      ! Display the module information
   CALL DispNVD( Aqwa_Ver )

   
 !!  CALL ReadPrimaryFile( InitInp%InputFile, InputFileData, TRIM(InitInp%RootName)//'.Aqwa', ErrStatTmp, ErrMsgTmp )   
 !!     CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)


      ! SET outlist variables, so pass in to SetOutParam the full list
   TmpOutList  =  (/    &
                     "AqwaFxi  ","AqwaFyi  ","AqwaFzi  ","AqwaMxi  ","AqwaMyi  ","AqwaMzi  ",   &     ! Total forces / moments
                     "AqwaHMFxi","AqwaHMFyi","AqwaHMFzi","AqwaHMMxi","AqwaHMMyi","AqwaHMMzi",   &     ! hydrodynamic contributions
                     "AqwaAMFxi","AqwaAMFyi","AqwaAMFzi","AqwaAMMxi","AqwaAMMyi","AqwaAMMzi"    &     ! Added mass contributions
                  /)
   p%NumOuts   =  MaxOutPts
   CALL SetOutParam( TmpOutList, p, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
   IF ( ErrStat>= AbortErrLev ) RETURN


      ! Allocate array for AllOuts
   CALL AllocAry( m%AllOuts, p%NumOuts, 'AllOuts', ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
   IF ( ErrStat>= AbortErrLev ) RETURN
   m%AllOuts = 0.0_ReKi
  

      ! Allocate arrays for the WriteOutput
   CALL AllocAry( y%WriteOutput, p%NumOuts, 'WriteOutput', ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
   IF ( ErrStat>= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   ENDIF
   y%WriteOutput = 0.0_ReKi
   
   CALL AllocAry( InitOut%WriteOutputHdr, p%NumOuts, 'WriteOutputHdr', ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
   IF ( ErrStat>= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   ENDIF

   CALL AllocAry( InitOut%WriteOutputUnt, p%NumOuts, 'WriteOutputUnt', ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
   IF ( ErrStat>= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   ENDIF

   InitOut%WriteOutputHdr = p%OutParam(1:p%NumOuts)%Name
   InitOut%WriteOutputUnt = p%OutParam(1:p%NumOuts)%Units     
 


      ! Init routine load
   p%DLL_Aqwa%FileName     = InputFileData%DLL_FileName
   p%DLL_Aqwa%ProcName(1)  = InputFileData%DLL_InitProcName
   p%DLL_Aqwa%ProcName(2)  = InputFileData%DLL_CalcProcName
   p%DLL_Aqwa%ProcName(3)  = InputFileData%DLL_EndProcName

   
   !!To Remove the following when sure RRD
!!!#ifdef NO_LibLoad
!!!   CALL SetErrStat( ErrID_Warn,'   -->  Skipping LoadDynamicLib call for '//TRIM(p%DLL_Aqwa%FileName),ErrStat,ErrMsg,RoutineName )
!!!#else
!!!   CALL LoadDynamicLib ( p%DLL_Aqwa, ErrStatTmp, ErrMsgTmp )
!!!   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)
!!!   IF ( ErrStat >= AbortErrLev ) THEN
!!!      CALL CleanUp
!!!      RETURN
!!!   END IF
!!!
!!!   CALL C_F_PROCPOINTER( p%DLL_Aqwa%ProcAddr(1), AqwaDLL_Init )
!!!#endif




      ! Set the values to pass to AqwaDLL_Init
   DLL_DT      =  Interval
   DLL_TMax    =  InitInp%TMax

   !To Remove the following when sure RRD
!!#ifdef NO_LibLoad
!!   CALL SetErrStat( ErrID_Warn,'   -->  Skipping AqwaDLL_Init call',ErrStat,ErrMsg,RoutineName )
!!#else
!!   CALL AqwaDLL_Init ( DLL_DT, DLL_TMax )
!!   ! Unfortunately, we don't get any error reporting back from AqwaDLL_Init, so we can't really check anything.
!!   !bjj: we should be warning people to use text output files instead of binary in case Aqwa crashes...
!!#endif


      ! Copy relevant information into parameters.
   p%SimNamePathLen  =  LEN_TRIM(InputFileData%DirRoot)+1
   p%SimNamePath     =  TRIM(InputFileData%DirRoot)//CHAR(0)


      ! Create the input and output meshes associated with lumped loads
   CALL MeshCreate(  BlankMesh         = u%PtfmMesh       , &
                     IOS               = COMPONENT_INPUT  , &
                     Nnodes            = 1                , &
                     ErrStat           = ErrStatTmp       , &
                     ErrMess           = ErrMsgTmp        , &
                     TranslationDisp   = .TRUE.           , &
                     Orientation       = .TRUE.           , &
                     TranslationVel    = .TRUE.           , &
                     RotationVel       = .TRUE.           , &
                     TranslationAcc    = .TRUE.           , &
                     RotationAcc       = .TRUE.)

   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL CleanUp
      RETURN
   END IF

      ! Create the node on the mesh
   CALL MeshPositionNode (u%PtfmMesh, 1, (/0.0_ReKi, 0.0_ReKi, 0.0_ReKi/), ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)

      ! Create the mesh element
   CALL MeshConstructElement (  u%PtfmMesh, ELEMENT_POINT, ErrStatTmp, ErrMsgTmp, 1 )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)

   CALL MeshCommit ( u%PtfmMesh, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL CleanUp
      RETURN
   END IF


   CALL MeshCopy( SrcMesh=u%PtfmMesh, DestMesh=y%PtfmMesh, CtrlCode=MESH_SIBLING, IOS=COMPONENT_OUTPUT, &
                  ErrStat=ErrStatTmp, ErrMess=ErrMsgTmp, Force=.TRUE., Moment=.TRUE. )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName)
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL CleanUp
      RETURN
   END IF


   u%PtfmMesh%RemapFlag    = .TRUE.
   y%PtfmMesh%RemapFlag    = .TRUE.




      ! Set zero values for the MiscVar arrays
   m%A2Fast_PtfmAM       =  0.0_ReKi
   m%A2Fast_PtfmFt       =  0.0_ReKi
   m%LastTimeStep =  -1.0_DbKi

   InitOut%Ver =  Aqwa_Ver


CONTAINS
   !------------------------------------------------------------------
   SUBROUTINE CleanUp()

      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Aqwa_DestroyInputFile(InputFileData, ErrStatTmp, ErrMsgTmp )
         CALL SetErrStat(ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName)
      END IF

   END SUBROUTINE CleanUp

END SUBROUTINE Aqwa_Init

!----------------------------------------------------------------------------------------------------------------------------------
!> This routine reads in the primary Aqwa Interface input file and places the values it reads in the InputFileData structure.
!!   It opens an echo file if requested.
SUBROUTINE ReadPrimaryFile( InputFile, InputFileData, OutFileRoot, ErrStat, ErrMsg )

   IMPLICIT                        NONE

      ! Passed variables
   INTEGER(IntKi),       INTENT(OUT)    :: ErrStat                             !< Error status
                         
   CHARACTER(*),         INTENT(IN)     :: InputFile                           !< Name of the file containing the primary input data
   CHARACTER(*),         INTENT(OUT)    :: ErrMsg                              !< Error message
   CHARACTER(*),         INTENT(IN)     :: OutFileRoot                         !< The rootname of the echo file, possibly opened in this routine
                         
   TYPE(Aqwa_InputFile), INTENT(INOUT)  :: InputFileData                     !< All the data in the Aqwa Interface input file

      ! Local variables:
   INTEGER(IntKi)               :: I                                         ! loop counter
!   INTEGER(IntKi)               :: NumOuts                                  ! Number of output channel names read from the file
   INTEGER(IntKi)               :: UnEc                                      ! I/O unit for echo file. If > 0, file is open for writing.
   INTEGER(IntKi)               :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)               :: IOS
   INTEGER(IntKi)               :: ErrStat2                                  ! Temporary Error status
   LOGICAL                      :: Echo                                      ! Determines if an echo file should be written
   CHARACTER(ErrMsgLen)         :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(1024)              :: PriPath                                   ! Path name of the primary file
   CHARACTER(1024)              :: CWD                                       ! Path name of the current working directory
   CHARACTER(1024)              :: FTitle                                    ! "File Title": the 2nd line of the input file, which contains a description of its contents
   CHARACTER(200)               :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(*), PARAMETER      :: RoutineName = 'ReadPrimaryFile' 
   
      ! Initialize some variables:
   Echo = .FALSE.
   UnEc = -1                             ! Echo file not opened, yet
   CALL GetPath( InputFile, PriPath )    ! Input files will be relative to the path where the primary input file is located.

      ! Aqwa doesn't like relative path names, so we're going to make it absolute
   IF ( PathIsRelative( PriPath ) ) THEN
       CALL GET_CWD(CWD, ErrStat2)
!       PriPath = TRIM(CWD)//PathSep//TRIM(PriPath)
       PriPath = TRIM(CWD)//TRIM(PriPath(2:))
   END IF
         

      ! Get an available unit number for the file.

   CALL GetNewUnit( UnIn, ErrStat, ErrMsg )
   IF ( ErrStat >= AbortErrLev ) RETURN


      ! Open the Primary input file.

   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) RETURN


   !CALL AllocAry( InputFileData%OutList, MaxOutPts, "Aqwa Interface Input File's Outlist", ErrStat2, ErrMsg2 )
   !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !   IF ( ErrStat >= AbortErrLev ) RETURN


   ! Read the lines up/including to the "Echo" simulation control variable
   ! If echo is FALSE, don't write these lines to the echo file.
   ! If Echo is TRUE, rewind and write on the second try.

   I    = 1 ! the number of times we've read the file (used for the Echo variable)
   DO
   !-------------------------- HEADER ---------------------------------------------
      CALL ReadCom( UnIn, InputFile, 'File Header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      CALL ReadStr( UnIn, InputFile, FTitle, 'FTitle', 'File Header: File Description (line 2)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

   !---------------------- SIMULATION DATA --------------------------------------
      CALL ReadCom( UnIn, InputFile, 'Section Header: Simulation Control', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

         ! Echo - Echo input to "<RootName>.ech".

      CALL ReadVar( UnIn, InputFile, Echo, 'Echo',   'Echo switch', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF


      IF (.NOT. Echo .OR. I > 1) EXIT !exit this loop

         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read

      I = I + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)

      CALL OpenEcho ( UnEc, TRIM(OutFileRoot)//'.ech', ErrStat2, ErrMsg2, Aqwa_Ver )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      IF ( UnEc > 0 )  WRITE (UnEc,'(/,A,/)')  'Data from '//TRIM(Aqwa_Ver%Name)//' primary input file "'//TRIM( InputFile )//'":'

      REWIND( UnIn, IOSTAT=ErrStat2 )
         IF (ErrStat2 /= 0_IntKi ) THEN
            CALL SetErrStat( ErrID_Fatal, 'Error rewinding file "'//TRIM(InputFile)//'".', ErrStat, ErrMsg, RoutineName )
            CALL Cleanup()
            RETURN
         END IF

   END DO

   IF (NWTC_VerboseLevel == NWTC_Verbose) THEN
      CALL WrScr( ' Heading of the '//TRIM(Aqwa_Ver%Name)//' input file: ' )
      CALL WrScr( '   '//TRIM( FTitle ) )
   END IF


      ! InputFileData%DirRoot - Name of the file containing Aqwa simulation inputs:
   CALL ReadVar ( UnIn, InputFile, InputFileData%DirRoot, 'DirRoot', 'Name of the Aqwa simulation input file', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF
   IF ( PathIsRelative( InputFileData%DirRoot ) ) InputFileData%DirRoot = TRIM(PriPath)//TRIM(InputFileData%DirRoot)
   
      ! InputFileData%DLLPathFileName - Name of the file containing Aqwa simulation inputs:
   CALL ReadVar ( UnIn, InputFile, InputFileData%DLL_FileName, 'DLL_FileName', 'Name of the Aqwa DLL', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF
   IF ( PathIsRelative( InputFileData%DLL_FileName ) ) InputFileData%DLL_FileName = TRIM(PriPath)//TRIM(InputFileData%DLL_FileName)
   
         
   !   ! DT - Requested integration time for Aqwa (seconds):
   !CALL ReadVar( UnIn, InputFile, Line, "DT", "Requested integration time for Aqwa (seconds)", ErrStat2, ErrMsg2, UnEc)
   !   CALL CheckError( ErrStat2, ErrMsg2 )
   !   IF ( ErrStat >= AbortErrLev ) RETURN
   !   CALL Conv2UC( Line )
   !   IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DT
   !      READ( Line, *, IOSTAT=IOS) InputFileData%DT
   !      IF ( IOS /= 0 ) THEN
   !         CALL CheckIOS ( IOS, InputFile, "DT", NumType, ErrStat2, ErrMsg2 )
   !         CALL CheckError( ErrStat2, ErrMsg2 )
   !         RETURN
   !      END IF
   !   END IF
   
   
   !!---------------------- OUTLIST  --------------------------------------------
   !CALL ReadCom( UnIn, InputFile, 'Section Header: OutList', ErrStat2, ErrMsg2, UnEc )
   !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !   IF ( ErrStat >= AbortErrLev ) THEN
   !      CALL Cleanup()
   !      RETURN
   !   END IF
   !
   !   ! OutList - List of user-requested output channels (-):
   !CALL ReadOutputList ( UnIn, InputFile, InputFileData%OutList, InputFileData%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
   !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !   IF ( ErrStat >= AbortErrLev ) THEN
   !      CALL Cleanup()
   !      RETURN
   !   END IF

   !---------------------- END OF FILE -----------------------------------------

   CALL Cleanup()
   RETURN

CONTAINS
   SUBROUTINE Cleanup()
   
      CLOSE(UnIn)
      IF (UnEc > 0) CLOSE(UnEc)
      
   END SUBROUTINE Cleanup    
END SUBROUTINE ReadPrimaryFile
!----------------------------------------------------------------------------------------------------------------------------------


!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE Aqwa_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )

   TYPE(Aqwa_InputType),            INTENT(INOUT)  :: u           !< System inputs
   TYPE(Aqwa_ParameterType),        INTENT(INOUT)  :: p           !< Parameters
   TYPE(Aqwa_ContinuousStateType),  INTENT(INOUT)  :: x           !< Continuous states
   TYPE(Aqwa_DiscreteStateType),    INTENT(INOUT)  :: xd          !< Discrete states
   TYPE(Aqwa_ConstraintStateType),  INTENT(INOUT)  :: z           !< Constraint states
   TYPE(Aqwa_OtherStateType),       INTENT(INOUT)  :: OtherState  !< Other states
   TYPE(Aqwa_OutputType),           INTENT(INOUT)  :: y           !< System outputs
   TYPE(Aqwa_MiscVarType),          INTENT(INOUT)  :: m           !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

   PROCEDURE(AqwaUserPtfmLdFinalise),  POINTER :: AqwaDLL_End

      ! Error Handling
   INTEGER(IntKi)                                  :: ErrStatTmp        ! temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsgTmp         ! temporary Error message if ErrStat /= ErrID_None
   CHARACTER(*),   PARAMETER                       :: RoutineName='Aqwa_End'


      ! Initialize ErrStat
   ErrStat     = ErrID_None
   ErrMsg      = ""
   ErrStatTmp  = ErrID_None
   ErrMsgTmp   = ""




#ifdef NO_LibLoad
   CALL SetErrStat( ErrID_Warn,'   -->  Skipping AqwaDLL_End call',ErrStat,ErrMsg,RoutineName )
#else
      ! Release the DLL
   CALL C_F_PROCPOINTER( p%DLL_Aqwa%ProcAddr(3), AqwaDLL_End )
   CALL AqwaDLL_End        ! No error handling here.  Just have to assume it worked.


   CALL FreeDynamicLib( p%DLL_Aqwa, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )   
#endif


      ! Destroy the input data:
   CALL Aqwa_DestroyInput( u, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )


      ! Destroy the parameter data:
#ifdef NO_LibLoad
#else
   CALL Aqwa_DestroyParam( p, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )
#endif


      ! Destroy the state data:
   CALL Aqwa_DestroyContState(   x,           ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )
   CALL Aqwa_DestroyDiscState(   xd,          ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )
   CALL Aqwa_DestroyConstrState( z,           ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )
   CALL Aqwa_DestroyOtherState(  OtherState,  ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )

      ! Destroy misc variables:
   CALL Aqwa_DestroyMisc(  m,  ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )

   
      ! Destroy the output data:
   CALL Aqwa_DestroyOutput( y, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp,ErrMsgTmp,ErrStat,ErrMsg,RoutineName )


END SUBROUTINE Aqwa_End
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine for computing outputs, used in both loose and tight coupling.
!! This SUBROUTINE is used to compute the output channels (motions and loads) and place them in the WriteOutput() array.
!! NOTE: the descriptions of the output channels are not given here. Please see the included OutListParameters.xlsx sheet for
!! for a complete description of each output parameter.
!! NOTE: no matter how many channels are selected for output, all of the outputs are calcalated
!! All of the calculated output channels are placed into the m%AllOuts(:), while the channels selected for outputs are
!! placed in the y%WriteOutput(:) array.
SUBROUTINE Aqwa_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )

   REAL(DbKi),                      INTENT(IN   )  :: t                 !< Current simulation time in seconds
   TYPE(Aqwa_InputType),            INTENT(IN   )  :: u                 !< Inputs at Time t
   TYPE(Aqwa_ParameterType),        INTENT(IN   )  :: p                 !< Parameters
   TYPE(Aqwa_ContinuousStateType),  INTENT(IN   )  :: x                 !< Continuous states at t
   TYPE(Aqwa_DiscreteStateType),    INTENT(IN   )  :: xd                !< Discrete states at t
   TYPE(Aqwa_ConstraintStateType),  INTENT(IN   )  :: z                 !< Constraint states at t
   TYPE(Aqwa_OtherStateType),       INTENT(IN   )  :: OtherState        !< Other states at t
   TYPE(Aqwa_OutputType),           INTENT(INOUT)  :: y                 !< Outputs computed at t (Input only so that mesh con-
                                                                        !!   nectivity information does not have to be recalculated)
   TYPE(Aqwa_MiscVarType),          INTENT(INOUT)  :: m                 !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat           !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg            !< Error message if ErrStat /= ErrID_None

   
      ! Local variables copied from the mesh
   REAL(ReKi)                                      :: rotdisp(3)        !< Rotation angles from the mesh
   REAL(ReKi)                                      :: q(6)              !< Position from the mesh
   REAL(ReKi)                                      :: qdot(6)           !< Time derivative of position (velocity) from mesh
   REAL(ReKi)                                      :: qdotdot(6)        !< 2nd time derivative of position (acceleration) from mesh


      ! Local variables for data manipulation
   INTEGER(IntKi)                                  :: I,J               !< Generic counters



      ! Local variables for the getting the types correct to pass to the DLL
   CHARACTER(LEN=p%SimNamePathLen)                 :: DLL_DirRootName   !< Path and simulation name without extension
   !REAL(C_FLOAT)                                   :: F2Aqwa_X(6)          !< Translational and rotational displacement (m, radians) relative to inertial frame.
   !REAL(C_FLOAT)                                   :: F2Aqwa_Xdot(6)       !< Translational and rotational velocity (m/s, radians/s) relative to inertial frame.
   REAL(C_FLOAT)                                   :: DLL_ZTime         !< Current time in seconds
   REAL(C_FLOAT)                                   :: A2Fast_PtfmAM(6,6)   !< Added mass matrix (kg, kg-m, kg-m^2)
   REAL(C_FLOAT)                                   :: A2Fast_PtfmFt(6)     !< Platform forces -- [3 translation (N), 3 moments (N-m)] at reference point.


      ! Error Handling and data checking
   INTEGER(IntKi)                                  :: ErrStatTmp        !< Temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsgTmp         !< Temporary Error message if ErrStat /= ErrID_None
  
   REAL(ReKi),       PARAMETER                     :: SymmetryTol =  9.999E-4_ReKi  !< Tolerance used to determine if the PtfmAM is symmetric
   CHARACTER(*),   PARAMETER                       :: RoutineName = 'Aqwa_CalcOutput'

      ! Copy over time and name to pass to Aqwa DLL
   DLL_DirRootName   =  TRIM(p%SimNamePath)//C_NULL_CHAR    ! Path and name of the simulation file without extension.  Null character added to convert from Fortran string to C-type string.
   DLL_ZTime = t                                            ! Current time

      ! Determine the rotational angles from the direction-cosine matrix
   rotdisp = GetSmllRotAngs ( u%PtfmMesh%Orientation(:,:,1), ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName )
   IF ( ErrStat >= ErrID_Fatal) RETURN

   q         = reshape((/REAL(u%PtfmMesh%TranslationDisp(:,1),ReKi),rotdisp(:)/),(/6/))
   qdot      = reshape((/u%PtfmMesh%TranslationVel(:,1),u%PtfmMesh%RotationVel(:,1)/),(/6/))
   qdotdot   = reshape((/u%PtfmMesh%TranslationAcc(:,1),u%PtfmMesh%RotationAcc(:,1)/),(/6/))

   !!Following lines have been moved to UpdateStates
   !!   ! Copy position and motion information over to pass to Aqwa; note this is a way to pass this time-step info to Aqwa to do its calc for next time step, syncopated
   !!
   !!m%F2Aqwa_q    =  q
   !!m%F2Aqwa_qd   =  qdot
   !!m%F2Aqwa_qdd  =  qdotdot
   !!   
   !!   ! Make sure this is synced to the C versions too
   !!m%c_obj%F2Aqwa_q_Len = 6; m%c_obj%F2Aqwa_q = C_LOC( m%F2Aqwa_q )
   !!m%c_obj%F2Aqwa_qd_Len = 6; m%c_obj%F2Aqwa_qd = C_LOC( m%F2Aqwa_qd )
   !!m%c_obj%F2Aqwa_qdd_Len = 6; m%c_obj%F2Aqwa_qdd = C_LOC( m%F2Aqwa_qdd )
   
      ! Now get the results from Aqwa  
   m%LastTimeStep =  t
      ! We do not want to call AqwaDLL twice in one timestep.  If _CalcOutput is called twice in a timestep, the second
      ! call is different from the first only with the accelerations, which Aqwa does not do anything with.   ?????RRD
      !IF ( t > m%LastTimeStep .and. .not. EqualRealNos(t,m%LastTimeStep) ) THEN
      

         ! Need to unwrap the Aqwa Added Mass that comes in as a flat array: TO DO
     !! DO I=1,6
     !!   m%PtfmFT(I) =  Aqwa_PtfmFT(I)
     !!    DO J=1,6
     !!       m%PtfmAM(J,I)  =  Aqwa_PtfmAM(J,I)
     !!    ENDDO
     !! ENDDO

   
      ! Now calculate the forces with what Aqwa returned
   m%F_PtfmAM     =  -matmul(m%A2Fast_PtfmAM, qdotdot)



      ! Update the Mesh with values from Aqwa
   DO I=1,3
      y%PtfmMesh%Force(I,1)  =  m%F_PtfmAM(I)   +  m%A2Fast_PtfmFT(I)
      y%PtfmMesh%Moment(I,1) =  m%F_PtfmAM(I+3) +  m%A2Fast_PtfmFT(I+3)
   ENDDO

   

      ! Set all the outputs
   CALL SetAllOuts( p, y, m, ErrStatTmp, ErrMsgTmp )
   CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName )
   IF ( ErrStat >= ErrID_Fatal) RETURN



   RETURN


END SUBROUTINE Aqwa_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other 
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE Aqwa_UpdateStates( t, n, u, utimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )

      REAL(DbKi),                         INTENT(IN   ) :: t          !< Current simulation time in seconds
      INTEGER(IntKi),                     INTENT(IN   ) :: n          !< Current simulation time step n = 0,1,...
      TYPE(Aqwa_InputType),               INTENT(INOUT) :: u(:)       !< Inputs at utimes (out only for mesh record-keeping in ExtrapInterp routine)
      REAL(DbKi),                         INTENT(IN   ) :: utimes(:)  !< Times associated with u(:), in seconds
      TYPE(Aqwa_ParameterType),           INTENT(IN   ) :: p          !< Parameters
      TYPE(Aqwa_ContinuousStateType),     INTENT(INOUT) :: x          !< Input: Continuous states at t;
                                                                      !!   Output: Continuous states at t + Interval
      TYPE(Aqwa_DiscreteStateType),       INTENT(INOUT) :: xd         !< Input: Discrete states at t;
                                                                      !!   Output: Discrete states at t  + Interval
      TYPE(Aqwa_ConstraintStateType),     INTENT(INOUT) :: z          !< Input: Initial guess of constraint states at t+dt;
                                                                      !!   Output: Constraint states at t+dt
      TYPE(Aqwa_OtherStateType),          INTENT(INOUT) :: OtherState !< Other states: Other states at t;
                                                                      !!   Output: Other states at t + Interval
      TYPE(Aqwa_MiscVarType),             INTENT(INOUT) :: m          !<  Misc variables for optimization (not copied in glue code)
      INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat    !< Error status of the operation
      CHARACTER(*),                       INTENT(  OUT) :: ErrMsg     !< Error message if ErrStat /= ErrID_None


            ! Local variables copied from the mesh
   REAL(ReKi)                                      :: rotdisp(3)        !< Rotation angles from the mesh
   REAL(ReKi)                                      :: q(6)              !< Position from the mesh
   REAL(ReKi)                                      :: qdot(6)           !< Time derivative of position (velocity) from mesh
   REAL(ReKi)                                      :: qdotdot(6)        !< 2nd time derivative of position (acceleration) from mesh
      ! Error Handling and data checking
   INTEGER(IntKi)                                  :: ErrStatTmp        !< Temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsgTmp         !< Temporary Error message if ErrStat /= ErrID_None
   CHARACTER(*),   PARAMETER                       :: RoutineName = 'Aqwa_CalcOutput'
         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


          ! Determine the rotational angles from the direction-cosine matrix: To Figure out which u to use for now u=u(1)
       rotdisp = GetSmllRotAngs ( u(1)%PtfmMesh%Orientation(:,:,1), ErrStatTmp, ErrMsgTmp )
       CALL SetErrStat( ErrStatTmp, ErrMsgTmp, ErrStat, ErrMsg, RoutineName )
       IF ( ErrStat >= ErrID_Fatal) RETURN

       q         = reshape((/REAL(u(1)%PtfmMesh%TranslationDisp(:,1),ReKi),rotdisp(:)/),(/6/))
       qdot      = reshape((/u(1)%PtfmMesh%TranslationVel(:,1),u(1)%PtfmMesh%RotationVel(:,1)/),(/6/))
       qdotdot   = reshape((/u(1)%PtfmMesh%TranslationAcc(:,1),u(1)%PtfmMesh%RotationAcc(:,1)/),(/6/))


          ! Copy position and motion information over to pass to Aqwa; note this is a way to pass this time-step info to Aqwa to do its calc for next time step, syncopated
   
       m%F2Aqwa_q    =  q
       m%F2Aqwa_qd   =  qdot
       m%F2Aqwa_qdd  =  qdotdot
       

END SUBROUTINE Aqwa_UpdateStates
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 01-Sep-2015 14:29:18.
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
! This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
! warning if any of the channels are not available outputs from the module.
!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!  the sign is set to 0 if the channel is invalid.
! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        ! The list out user-requested outputs
   TYPE(Aqwa_ParameterType),  INTENT(INOUT)  :: p                                 ! The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            ! The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(18) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "AqwaAMFXI","AqwaAMFYI","AqwaAMFZI",  &
                               "AqwaAMMXI","AqwaAMMYI","AqwaAMMZI",  &
                               "AqwaFXI  ","AqwaFYI  ","AqwaFZI  ",  &
                               "AqwaHMFXI","AqwaHMFYI","AqwaHMFZI",  &
                               "AqwaHMMXI","AqwaHMMYI","AqwaHMMZI",  &
                               "AqwaMXI  ","AqwaMYI  ","AqwaMZI  "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(18) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                AqwaAMFxi , AqwaAMFyi , AqwaAMFzi ,  &
                                AqwaAMMxi , AqwaAMMyi , AqwaAMMzi ,  &
                                  AqwaFxi ,   AqwaFyi ,   AqwaFzi ,  &
                                AqwaHMFxi , AqwaHMFyi , AqwaHMFzi ,  &
                                AqwaHMMxi , AqwaHMMyi , AqwaHMMzi ,  &
                                  AqwaMxi ,   AqwaMyi ,   AqwaMzi /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(18) =  (/ &                      ! This lists the units corresponding to the allowed parameters
                               "(kN)      ","(kN)      ","(kN)      ",  &
                               "(kN m)    ","(kN m)    ","(kN m)    ",  &
                               "(kN)      ","(kN)      ","(kN)      ",  &
                               "(kN)      ","(kN)      ","(kN)      ",  &
                               "(kN m)    ","(kN m)    ","(kN m)    ",  &
                               "(kN m)    ","(kN m)    ","(kN m)    "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....

!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the AqwaInterface OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.


   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)


      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************

SUBROUTINE SetAllOuts( ParamData, OutData, m, ErrStat, ErrMsg )

   IMPLICIT                                              NONE

   CHARACTER(*),              PARAMETER               :: RoutineName="SetAllOuts"


   TYPE(Aqwa_ParameterType),           INTENT(IN   )  :: ParamData            !< The parameters for Aqwa
   TYPE(Aqwa_OutputType),              INTENT(INOUT)  :: OutData              !< Outputs
   TYPE(Aqwa_MiscVarType),             INTENT(INOUT)  :: m                    !< The MiscVars info for Aqwa
   INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat              !< Error status  from this subroutine
   CHARACTER(*),                       INTENT(  OUT)  :: ErrMsg               !< Error message from this subroutine


      ! Local Variables
   INTEGER(IntKi)                                     :: I                    !< Generic counter


      ! Initialization
   ErrStat  = ErrID_None
   ErrMsg   = ''


      ! Set the values
   m%AllOuts(  AqwaFxi  )  =  OutData%PtfmMesh%Force(1,1)/1000_ReKi
   m%AllOuts(  AqwaFyi  )  =  OutData%PtfmMesh%Force(2,1)/1000_ReKi
   m%AllOuts(  AqwaFzi  )  =  OutData%PtfmMesh%Force(3,1)/1000_ReKi
   m%AllOuts(  AqwaMxi  )  =  OutData%PtfmMesh%Moment(1,1)/1000_ReKi
   m%AllOuts(  AqwaMyi  )  =  OutData%PtfmMesh%Moment(2,1)/1000_ReKi
   m%AllOuts(  AqwaMzi  )  =  OutData%PtfmMesh%Moment(3,1)/1000_ReKi

   m%AllOuts(  AqwaHMFxi  )  =  m%A2Fast_PtfmFt(1)/1000_ReKi
   m%AllOuts(  AqwaHMFyi  )  =  m%A2Fast_PtfmFt(2)/1000_ReKi
   m%AllOuts(  AqwaHMFzi  )  =  m%A2Fast_PtfmFt(3)/1000_ReKi
   m%AllOuts(  AqwaHMMxi  )  =  m%A2Fast_PtfmFt(4)/1000_ReKi
   m%AllOuts(  AqwaHMMyi  )  =  m%A2Fast_PtfmFt(5)/1000_ReKi
   m%AllOuts(  AqwaHMMzi  )  =  m%A2Fast_PtfmFt(6)/1000_ReKi

   m%AllOuts(  AqwaAMFxi  )  =  m%F_PtfmAM(1)/1000_ReKi
   m%AllOuts(  AqwaAMFyi  )  =  m%F_PtfmAM(2)/1000_ReKi
   m%AllOuts(  AqwaAMFzi  )  =  m%F_PtfmAM(3)/1000_ReKi
   m%AllOuts(  AqwaAMMxi  )  =  m%F_PtfmAM(4)/1000_ReKi
   m%AllOuts(  AqwaAMMyi  )  =  m%F_PtfmAM(5)/1000_ReKi
   m%AllOuts(  AqwaAMMzi  )  =  m%F_PtfmAM(6)/1000_ReKi

      ! Set the values for the WriteOutput array
   OutData%WriteOutput(  AqwaFxi  )  =  OutData%PtfmMesh%Force(1,1)/1000_ReKi
   OutData%WriteOutput(  AqwaFyi  )  =  OutData%PtfmMesh%Force(2,1)/1000_ReKi
   OutData%WriteOutput(  AqwaFzi  )  =  OutData%PtfmMesh%Force(3,1)/1000_ReKi
   OutData%WriteOutput(  AqwaMxi  )  =  OutData%PtfmMesh%Moment(1,1)/1000_ReKi
   OutData%WriteOutput(  AqwaMyi  )  =  OutData%PtfmMesh%Moment(2,1)/1000_ReKi
   OutData%WriteOutput(  AqwaMzi  )  =  OutData%PtfmMesh%Moment(3,1)/1000_ReKi

   OutData%WriteOutput(  AqwaHMFxi  )  =  m%A2Fast_PtfmFt(1)/1000_ReKi
   OutData%WriteOutput(  AqwaHMFyi  )  =  m%A2Fast_PtfmFt(2)/1000_ReKi
   OutData%WriteOutput(  AqwaHMFzi  )  =  m%A2Fast_PtfmFt(3)/1000_ReKi
   OutData%WriteOutput(  AqwaHMMxi  )  =  m%A2Fast_PtfmFt(4)/1000_ReKi
   OutData%WriteOutput(  AqwaHMMyi  )  =  m%A2Fast_PtfmFt(5)/1000_ReKi
   OutData%WriteOutput(  AqwaHMMzi  )  =  m%A2Fast_PtfmFt(6)/1000_ReKi

   OutData%WriteOutput(  AqwaAMFxi  )  =  m%F_PtfmAM(1)/1000_ReKi
   OutData%WriteOutput(  AqwaAMFyi  )  =  m%F_PtfmAM(2)/1000_ReKi
   OutData%WriteOutput(  AqwaAMFzi  )  =  m%F_PtfmAM(3)/1000_ReKi
   OutData%WriteOutput(  AqwaAMMxi  )  =  m%F_PtfmAM(4)/1000_ReKi
   OutData%WriteOutput(  AqwaAMMyi  )  =  m%F_PtfmAM(5)/1000_ReKi
   OutData%WriteOutput(  AqwaAMMzi  )  =  m%F_PtfmAM(6)/1000_ReKi


END SUBROUTINE SetAllOuts




END MODULE AqwaInterface
!**********************************************************************************************************************************
